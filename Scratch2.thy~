theory Scratch2
  imports Main "WSet" "HOL.Rings" "HOL-Library.Finite_Map" "HOL-Library.BNF_Corec" 

begin

subsection \<open>The type of weighted sets\<close>

(* Definition of weights, weighted sets and graphs*)
class ssr = linorder + ab_semigroup_add_test +
  fixes oplus :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"  (infixl "\<oplus>" 65)
  fixes otimes :: "'a \<Rightarrow> 'a \<Rightarrow> 'a" (infixl "\<otimes>" 70)
  fixes one :: "'a"
  fixes monus :: "'a \<Rightarrow> 'a \<Rightarrow> 'a"
  assumes right_neutral: "t \<otimes> one = t"
  assumes left_neutral: "one \<otimes> t = t"
  assumes distribute: "(a + b) \<otimes> c = (a \<otimes> c) + (b \<otimes> c)"

definition returnwset :: "'a \<Rightarrow> ('a, 's::ssr) wset" where
  "returnwset el = wsingle el one"


print_classes

instantiation nat :: ssr begin
definition oplus_nat :: "nat \<Rightarrow> nat \<Rightarrow> nat" where "oplus_nat a b = min a b"
definition otimes_nat :: "nat \<Rightarrow> nat \<Rightarrow> nat" where "otimes_nat a b = a + b"
definition one_nat :: "nat" where "one_nat = 0"
definition monus_nat :: "nat \<Rightarrow> nat \<Rightarrow> nat" where "monus_nat a b = a-b"

instance proof 
  fix t::nat show "t \<otimes> one = t"
    unfolding one_nat_def otimes_nat_def
    by simp
next
  fix t::nat show "one \<otimes> t = t"
    unfolding one_nat_def otimes_nat_def
    by simp
next
  fix a b c d :: nat assume "a + b = c + d"
  then show "\<exists>e11 e12 e21 e22.
          Some a = e11 + e12 \<and>
          Some b = e21 + e22 \<and> Some c = e11 + e21 \<and> Some d = e12 + e22"
    sorry
next
  fix a b c :: nat show "(a + b) \<otimes> c = (a \<otimes> c) + (b \<otimes> c)"
    sorry
qed
end


type_synonym ('a, 's) GraphOfwset = "'a \<Rightarrow> ('a, 's) wset"

(* Scaling of weighted sets *)
context includes wset.lifting begin
lift_definition scalewset :: "('s::ssr \<Rightarrow> 's) \<Rightarrow> ('a, 's) wset \<Rightarrow> ('a, 's) wset" is
  "\<lambda>f. \<lambda>w. \<lambda>el. Option.bind (w el) (\<lambda>x. Some(f x))"
  subgoal for scalar w
    apply (auto split: if_splits simp: dom_def)
    by (simp add: bind_eq_Some_conv)
  done
end

(* EDGE SEMIRING *)
(* Graph-union, \<oplus> *)
definition unionGraph :: "('a, 's::ssr) GraphOfwset \<Rightarrow> ('a, 's::ssr) GraphOfwset  \<Rightarrow> ('a, 's::ssr) GraphOfwset" where
  "unionGraph f g x = wadd (f x) (g x)"

(* Empty graph, \<zero> *)
definition emptyGraph :: "('a, 's::ssr) GraphOfwset" where
  "emptyGraph x = wempty"

(* Connect-operator, \<otimes> *)
lift_definition connectGraph :: "('a, 's::ssr) GraphOfwset \<Rightarrow> ('a, 's::ssr) GraphOfwset  \<Rightarrow> ('a, 's::ssr) GraphOfwset" is
   "\<lambda>G1 G2 (u :: 'a) (v :: 'a). let X = {s. \<exists>(w :: 'a) s1 s2.
      G1 u w = Some s1 \<and> G2 w v = Some s2 \<and> s = s1 + s2} in (if X = {} then None else Some (Min X))"
  subgoal for G1 G2 u
    apply (rule finite_subset[where B="\<Union>v \<in> dom (G1 u). dom (G2 v)"])
     apply (auto split: if_splits simp: dom_def)
    done
  done

(* Return-graph, \<one> *)
definition returnGraph :: "('a, 's::ssr) GraphOfwset" where
  "returnGraph x = wset_of_list [(x, one)]"

(* Monad implementation *)
lift_definition bindwset :: "('a, 's::ssr) wset \<Rightarrow> ('a \<Rightarrow> ('b, 's) wset) \<Rightarrow> ('b, 's) wset" is
  "\<lambda>(w :: 'a \<Rightarrow> 's option) k (el :: 'b). (
  let (X :: 's set) = {s. \<exists>x t1 t2. w x = Some t1 \<and> k x el = Some t2 \<and> s = t1 \<otimes> t2} in
  Finite_Set.fold (\<lambda>x y. Some x + y) None X)"
  (*Finite_Set.fold (\<lambda>x y. Option.bind y (\<lambda>y1. Some (y1 \<oplus> x))) None X)"*)
  subgoal for w k
    apply (rule finite_subset[where B="\<Union>v \<in> dom w. dom (k v)"])
     apply (auto split: if_splits simp: dom_def)
    subgoal for x y
      apply(cases "{s. \<exists>xa t1. w xa = Some t1 \<and> (\<exists>t2. k xa x = Some t2 \<and> s = t1 \<otimes> t2)} = {}")
       apply(auto)
      done
    done
  done
(*Finite_Set.fold (\<lambda>x y. Some x + y) None X)"*)

(* Algorithms with edge semiring *)
(* Naive-star is endlessly recursive, but maybe possibly corecursive
fun naiveStar :: "('a, 's::ssr) GraphOfwset \<Rightarrow> ('a, 's) GraphOfwset" where
  "naiveStar g = unionGraph returnGraph (connectGraph (naiveStar g) g)"*)

fun exp :: "('a, 's::ssr) GraphOfwset \<Rightarrow> nat \<Rightarrow> ('a, 's) GraphOfwset" where
  "exp g 0 = returnGraph" |
  "exp g (Suc n) = connectGraph g (exp g n)"

lemma finite_image_from_w:
  assumes "finite {a. \<exists>y. w a = Some y}"
  shows "finite {a. \<exists>x xa. f xa = a \<and> w xa = Some x}"
proof -
  have "{a. \<exists>x xa. f xa = a \<and> w xa = Some x} = f ` {xa. \<exists>y. w xa = Some y}"
    by auto
  then show ?thesis using assms
    by auto
qed

context includes wset.lifting begin
lift_definition mapwset :: "('a \<Rightarrow> 'b) \<Rightarrow> ('a, 's::ssr) wset \<Rightarrow> ('b, 's) wset" is
  "\<lambda>(f::'a \<Rightarrow> 'b). \<lambda>(w::'a \<Rightarrow> 's option). \<lambda>(el:: 'b). 
  (let X = {s. \<exists>x. f x = el \<and> w x = Some s} in
  if X = {} then None else Some(Min X))"
  subgoal for f w
    apply (auto split: if_splits simp: dom_def)
    by (simp add: finite_image_from_w)
  done
end

datatype 'a list_plus = Single 'a | Snoc "'a list_plus" 'a

fun pathed :: "('a, 's::ssr) GraphOfwset \<Rightarrow> ('a list_plus, 's) GraphOfwset" where
  "pathed g (Snoc vs v) = mapwset (\<lambda>t. Snoc (Snoc vs v) t) (g v)" |
  "pathed g (Single v) = mapwset (\<lambda>t. Snoc (Single v) t) (g v)"

context includes wset.lifting begin
lift_definition filtering :: "('a \<Rightarrow> bool) \<Rightarrow> ('a, 's::ssr) GraphOfwset" is
  "\<lambda>p v el. (if p v \<and> v = el then Some one else None)"
  by (auto split: if_splits simp: dom_def)
end

lemma addToEmptySet[simp]: "wadd (wsingle x one) wempty 
  = wsingle x one"
  unfolding wadd_def wsingle_def wempty_def
  apply(auto)
  by (metis (no_types, lifting) ext wempty.rep_eq wset.weight_inverse
      add.right_neutral zero_option_def)


lemma filtering_true_equals_return: "returnGraph = filtering (\<lambda>x. True)"
  unfolding filtering_def returnGraph_def
  apply (auto split: if_splits)
  unfolding wsingle_def map_fun_def
  apply(simp)
  by auto
  
  

(* THE VERTEX SEMIRING *)









type_synonym ('s, 'a) link = "('s \<times> 'a) option"
(*codatatype ('s, 'a) chain = Chain 'a "('s \<times> ('s, 'a) chain) option"*)
codatatype ('s, 'a) chain = Chain 'a "('s, ('s, 'a) chain) link"
codatatype ('s, 'a) heap = Heap 'a "(('s \<times> ('s, 'a) heap) list)"

fun bowtie :: "'s::ssr \<times> ('s, 'a) heap \<Rightarrow> 's \<times> ('s, 'a) heap \<Rightarrow> 's \<times> ('s, 'a) heap" where
  "bowtie (wl, Heap pl chl) (wr, Heap pr chr) = (
    if (wl \<le> wr) then
      (wl, Heap pl ((monus wr wl, Heap pr chr) # chl))
    else
      (wr, Heap pr ((monus wl wr, Heap pl chl) # chr))
  )"
notation bowtie (infixl "\<bowtie>" 65)

fun merges_plus :: "('s::ssr \<times> ('s, 'a) heap) \<Rightarrow> ('s \<times> ('s, 'a) heap) list \<Rightarrow> ('s \<times> ('s, 'a) heap)" where
  "merges_plus x [] = x" |
  "merges_plus x1 [x2] = x1 \<bowtie> x2" |
  "merges_plus x1 (x2#x3#xs) = (x1 \<bowtie> x2) \<bowtie> merges_plus x3 xs"

fun merges :: "('s::ssr \<times> ('s, 'a) heap) list \<Rightarrow> ('s, ('s, 'a) heap) link" where
  "merges [] = None" |
  "merges (x#xs) = Some (merges_plus x xs)"

definition map2 :: "('a \<Rightarrow> 'b) \<Rightarrow> ('c \<times> 'a) \<Rightarrow> ('c \<times> 'b)" where
  "map2 f p = (let (c, a) = p in (c, f a))"

fun outHeap :: "('s, 'a) heap \<Rightarrow> ('a \<times> (('s \<times> ('s, 'a) heap) list))" where
  "outHeap (Heap p ch) = (p, ch)"

primcorec test_chain :: "'a \<Rightarrow> 's \<Rightarrow> ('s, 'a) chain" where
  "test_chain a s = Chain a (Some(s, test_chain a s))"

primcorec search::"('s::ssr, 'a) heap \<Rightarrow> ('s, 'a) chain" where
  "search h = (
  let (a, h_opt) = map_prod id merges (outHeap h) in
  Chain a (map_option (map_prod id search) h_opt))
"
(*
datatype Vertex = a | b | c | d
definition test_heap :: "(nat, Vertex) heap" where
  "test_heap = Heap a [(7, Heap b [(8, Heap c [(11, Heap d [])])]), (2, Heap c [(5, Heap d [])])]"

value "search test_heap"
value "(2, test_heap) \<bowtie> (1, test_heap)"

term Heap
*)
fun list_plus_contains :: "'a list_plus \<Rightarrow> 'a \<Rightarrow> bool" where
  "list_plus_contains (Single x) y = (x = y)" |
  "list_plus_contains (Snoc xs x) y = ((x = y) \<or> list_plus_contains xs y)"

fun uniq :: "'a list_plus \<Rightarrow> bool" where
  "uniq (Single x) = True" |
  "uniq (Snoc xs x) = (\<not> list_plus_contains xs x \<and> uniq xs)"

type_synonym ('a, 's) LWeighted = "('a \<times> 's) list"

declare [[typedef_overloaded]]
codatatype ('a, 'w::ssr) wsetinf = WSetInf (outwsetinf: "('a, 'w) Forest + 'a")
and ('a ,'w) Forest = Forest "(('a, 'w) wsetinf, 'w) wset"
definition returnwsetinf :: "'a \<Rightarrow> ('a, 'w::ssr) wsetinf" where
"returnwsetinf x = WSetInf (Inr x)"

(*type_synonym ('a, 's) Forest = "(('a, 's) wsetinf, 's) wset"*)
definition returnForest :: "'a \<Rightarrow> ('a, 'w::ssr) Forest" where
"returnForest x = Forest (returnwset (returnwsetinf x))"

(*fun bindForest :: "('a, 'w::ssr) Forest \<Rightarrow> ('a \<Rightarrow> ('b, 'w) Forest) \<Rightarrow> ('b, 'w) Forest" where
"bindForest xs k = (let binder = (
    returnwset \<circ> WSetInf \<circ> Inl \<circ> ((case_sum (\<lambda>ys. bindForest ys k) k) \<circ> outwsetinf)
  ) in
  Forest (bindwset (un_Forest xs) binder))"*)

primcorec bindForest :: "('a, 'w::ssr) Forest \<Rightarrow> ('a \<Rightarrow> ('b, 'w) Forest) \<Rightarrow> ('b, 'w) Forest" 
  and bindwsetinf :: "('a \<Rightarrow> ('b, 'w) Forest) \<Rightarrow> ('a, 'w) wsetinf \<Rightarrow> ('b, 'w) wsetinf" where
  "bindForest xs k = Forest (image_wset (bindwsetinf k) (un_Forest xs))" |
  "bindwsetinf k xs = WSetInf (case outwsetinf xs of 
    Inl ys \<Rightarrow> Inl (bindForest ys k) 
  | Inr xs \<Rightarrow> Inl (k xs))"

(*lemma bind1[simp] : "bindwset A (f \<circ> g) = bindwset (image_wset g A) f"
  apply(transfer)
  apply(auto simp add: fun_eq_iff right_neutral)
  apply (metis option.exhaust)*)

lemma sumSome[simp]:"Some a + Some b = Some (a+b)"
  unfolding plus_option_def
  by auto

lemma fold_Some_exists:"finite S \<Longrightarrow> S\<noteq>{} \<Longrightarrow> None \<notin> A `S \<Longrightarrow> \<exists>t1. Finite_Set.fold (\<lambda>a. (+) (A a)) B S = Some t1"
proof (induction S arbitrary:B rule: finite_induct)
  case empty
  then show ?case
    by simp
next
  case (insert x F)
  then show ?case
    apply(subst comp_fun_commute_on.fold_insert_remove
        [where S="UNIV" and x="x" and A="F" and f="\<lambda>a. (+) (A a)"])
       apply(auto simp:)
     apply(unfold_locales; auto simp:comp_def fun_eq_iff ac_simps)
    apply(cases "A x"; simp; cases "Finite_Set.fold (\<lambda>a. (+) (A a)) B F"; simp add: plus_option_def)
    done
qed


theorem wset_induct [case_names empty add, induct type: wset]:
  assumes empty: "P wempty"
  assumes add: "\<And>x w M. P M \<Longrightarrow> weight M x = None \<Longrightarrow> P (wupdate M x (Some w))"
  shows "P M"
proof (rule wset_induct[where P=P, OF _ add])
  fix M :: "('a, 'b) wset"
  assume "\<And>x. weight M x = None"
  then have "M = wempty"
    by transfer auto
  then show "P M"
    using empty by simp
qed

(*
lemma bindwset_wupdate_None:
  "bindwset (wupdate M x None) k = wremove (k x) (bindwset M k)"
  sorry
*)
lemma bindwset_wupdate:
  "bindwset (wupdate M x (Some w)) k = wadd (scalewset ((\<otimes>) w) (k x)) (bindwset M k)"
  apply transfer
  unfolding bindwset_def
  apply (auto intro!:fun_eq_iff)

  sorry

lemma wadd_wempty[simp]: "wadd wempty A = A"
  apply(transfer)
  apply(auto)
  done

lemma bindwset_wempty[simp]: "bindwset wempty f = wempty"
  by transfer auto

lemma wadd_wupdate[simp]: "wadd (wupdate A x w) B = wupdate (wadd A B) x (w + weight B x)"
  apply(transfer)
  apply(auto)
  done

lemma Some_plus:"Some x + w = Some (case w of None \<Rightarrow> x | Some y \<Rightarrow> x+y)"
  by (auto simp:plus_option_def split:option.split)

lemma wadd_wempty_iff[simp]: "wadd A B = wempty \<longleftrightarrow> A = wempty \<and> B = wempty"
  by transfer (force simp: fun_eq_iff plus_option_def split: option.splits)

lemma wupdate_same: "weight A x = None \<Longrightarrow> wupdate A x None = A"
  apply transfer
  apply (auto simp: fun_eq_iff)
  done

lemma scalewset_distribute: "scalewset ((\<otimes>) (w + v)) M = wadd (scalewset ((\<otimes>) w) M) (scalewset ((\<otimes>) v) M)"
  apply (transfer)
  apply(auto simp:fun_eq_iff distribute split: Option.bind_splits)
  done

lemma bindwset_wadd: "bindwset (wadd A B) k = wadd (bindwset A k) (bindwset B k)"
proof (induction "wadd A B" arbitrary: A B)
  case empty
  then show ?case
    by (auto dest: sym)
next
  case (add x w C)
  have A: "A = wupdate (wupdate A x None) x (weight A x)" and B: "B = wupdate (wupdate B x None) x (weight B x)"
    by (transfer; auto)+
  from add(2,3) have "C = wadd (wupdate A x None) (wupdate B x None)" "weight A x + weight B x = Some w"
    by (transfer; auto simp: fun_eq_iff split: if_splits)+
  from add(1)[OF this(1)] this(2) add(3)[symmetric] add(2) this show ?case
    apply (auto simp: bindwset_wupdate)
    apply (subst (2) A)
    apply (subst (2) B)
    apply (cases "weight A x"; cases "weight B x")
       apply (auto simp: bindwset_wupdate scalewset_distribute)
      apply (drule wupdate_same[of A])
      apply (metis wadd_assoc wadd_commute)
     apply (drule wupdate_same[of B])
     apply (metis wadd_assoc)
    apply (smt (verit, best) wadd_assoc wadd_commute)
    done
qed

lemma bindwset_wsingle[simp]: "bindwset (wsingle x w) f = scalewset ((\<otimes>) w) (f x)"
  apply(transfer)
  apply(auto simp:fun_eq_iff)
  subgoal for x w f y
    apply(cases "f x y")
    apply(auto)
    done
  done
lemma bind1[simp] : "bindwset A (f \<circ> g) = bindwset (image_wset g A) f"
proof (induction A)
  case empty
  then show ?case
    by (simp add: wimage_empty)
next
  case (add x w A)
  then show ?case
    by (auto simp add: bindwset_wupdate w_image_update bindwset_wadd)
qed


lemma wupdate_None_wadd: "weight A x = None \<Longrightarrow> wupdate A x (Some w) = wadd (wsingle x w) A"
  unfolding wupdate_def
  apply (auto split:if_splits)
  by (metis add_Suc_right add_Suc_shift distribute n_not_Suc_n otimes_nat_def)

lemma bind2[simp] : "bindwset A returnwset = A"
proof (induction A)
  case empty
  then show ?case
    by simp
next
  case (add x w A)
  then show ?case
    find_theorems wupdate bindwset
    find_theorems wupdate wadd
    find_theorems wadd wupdate
    unfolding returnwset_def bindwset_def wupdate_def
    apply auto
    
    by (metis (mono_tags, lifting) add_diff_cancel_right' distribute le_imp_less_Suc left_neutral
        not_less_zero otimes_nat_def zero_le)
    
  (*by (metis option.exhaust)*)

lemma bind3[simp] : "bindwset (returnwset x) f = f x"
  unfolding returnwset_def
  apply(transfer)
  apply(auto simp add: fun_eq_iff right_neutral)
  sorry
  (*apply (metis option.exhaust)
  using left_neutral by blast*)

lemma mutualDefIsEqvWithPaper : "bindForest xs k = (let binder = (
    returnwset \<circ> WSetInf \<circ> Inl \<circ> ((case_sum (\<lambda>ys. bindForest ys k) k) \<circ> outwsetinf)
  ) in
  Forest (bindwset (un_Forest xs) binder))"
  apply (subst bindForest.code)
  apply (auto intro!:wset.map_cong simp add:wset.map_comp bindwsetinf.code split:sum.split)
  done

type_synonym ('a, 's) GraphOfForest = "'a \<Rightarrow> ('a, 's) Forest"

definition dfse :: "('a, 's::ssr) GraphOfForest \<Rightarrow> 'a \<Rightarrow> ('a + 'a, 's) Forest" where
  "dfse g x = Forest (wadd (un_Forest (returnForest (Inr x))) (un_Forest (bindForest (g x) (\<lambda>y. returnForest (Inl y)))))"

axiomatization dfsForest :: "('a, 's::ssr) GraphOfForest \<Rightarrow> 'a \<Rightarrow> ('a, 's) Forest" 
and dfswsetinf :: "('a, 's::ssr) GraphOfForest \<Rightarrow> ('a, 's) wsetinf \<Rightarrow> ('a, 's) wsetinf" where
  dfsForest_code:"dfsForest g x = Forest (image_wset (case_sum (dfswsetinf g) id) 
    (wadd (image_wset Inl (un_Forest (g x))) (returnwset (Inr (returnwsetinf x)))))" and
  dfswsetinf_code:"dfswsetinf g y = WSetInf (case outwsetinf y of
    Inl f \<Rightarrow> Inl (bindForest f (dfsForest g))
    | Inr a \<Rightarrow> (Inl (dfsForest g a)))" (*x is an either, need case*)

lemma implicReduce[simp]: "{a. x = a \<and> (x = a \<longrightarrow> f a = b)} = (if f x = b then {x} else {})"
  apply(auto)
  done

lemma image_wset_returnwset[simp]: "image_wset f (returnwset x) = returnwset (f x)"
  unfolding returnwset_def
  apply(transfer)
  apply(auto)
  done

lemma axiomizationEqvPaper:
  "dfsForest g x 
  = Forest (wadd (un_Forest (returnForest x)) (un_Forest (bindForest (g x) (\<lambda>y. dfsForest g y))))" 
proof - 
  have h1: "(returnwset (returnwsetinf x)) = un_Forest (returnForest x)"
    unfolding returnwset_def returnwsetinf_def returnForest_def
    by simp
  have "\<And>x. dfswsetinf g x = bindwsetinf (dfsForest g) x"
    subgoal for x
      unfolding dfswsetinf_code bindwsetinf.ctr
      apply(auto)
      done
    done
  have "\<And>ws. image_wset (dfswsetinf g) (un_Forest (Forest ws)) = un_Forest (bindForest (Forest ws) (dfsForest g))"
    subgoal for ws
      apply(auto)
      unfolding dfswsetinf_code 
      by (auto intro!:wset.map_cong split:sum.split simp add: bindwsetinf.code)
    done
  then have h2: "(image_wset (dfswsetinf g) (un_Forest (g x)) = un_Forest (bindForest (g x) (dfsForest g)))"
    apply (auto)
    done
  show ?thesis 
    unfolding h1[symmetric] h2[symmetric]
    apply (subst dfsForest_code)
    apply (auto simp: wset.map_comp comp_def wadd_commute)
    by (simp add: case_sum_o_inj(1) returnwset_def wimage_wadd_wsingle wset.map_comp)
qed
    
(*apply (auto intro!:wset.map_cong simp add:wset.map_comp bindwsetinf.code split:sum.split)
  done*)

(*fun dijkstra :: "'a \<Rightarrow> ('a, 's) GraphOfwset \<Rightarrow> ('a list_plus) Neighbours" where
  "dijkstra s g = connectwset (pathed g) (filtering uniq)"*)

end